name: Multi-App Deploy (push-based)

on:
  push:
    branches: ["main"]
    paths:
      - "clusters/**"
      - ".github/workflows/deploy-changed.yaml"
  workflow_dispatch:

concurrency:
  group: deploy-${{ vars.TARGET_CLUSTER || 'madiunkab' }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    env:
      TARGET_CLUSTER: ${{ vars.TARGET_CLUSTER || 'madiunkab' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Tooling (kubectl, helm, yq, jq)
        uses: azure/setup-kubectl@v4
        with: { version: "v1.30.0" }
      - uses: azure/setup-helm@v4
        with: { version: "v3.14.4" }
      - name: Install yq & jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          curl -L https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 -o yq
          sudo install yq /usr/local/bin/yq
          yq --version
          jq --version

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_CONTENT }}" > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl cluster-info

      - name: Detect changed apps
        id: detect
        run: |
          set -euo pipefail
          BASE_REF="$(git merge-base origin/main HEAD || echo HEAD~1)"
          ROOT="clusters/${TARGET_CLUSTER}"
          echo "ROOT=$ROOT"
          CHANGED=$(git diff --name-only "$BASE_REF"...HEAD | grep "^${ROOT}/" || true)
          echo "Changed files:"; echo "$CHANGED"

          # ambil direktori app yang terdampak (level 2: clusters/<cluster>/<app>/...)
          APPS=$(echo "$CHANGED" | awk -F'/' -v root="$ROOT" '$1"/"$2==root {print $3}' | sort -u)
          if [ -z "$APPS" ]; then
            echo "apps=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          MATRIX=$(printf '%s\n' "$APPS" | jq -R . | jq -s '{include: .}')
          echo "apps=$MATRIX" >> $GITHUB_OUTPUT
          echo "Matrix: $MATRIX"

      - name: Set matrix or skip
        id: matrix
        run: |
          M='${{ steps.detect.outputs.apps }}'
          if [ -z "$M" ]; then
            echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
          else
            echo "matrix=$M" >> $GITHUB_OUTPUT

      - name: Save matrix (debug)
        run: echo '${{ steps.matrix.outputs.matrix }}' > matrix.json

      - name: Preflight cleanup namespaces (optional)
        run: |
          for ns in cattle-system rancher-webhook cattle-monitoring-system; do
            if kubectl get ns "$ns" >/dev/null 2>&1; then
              phase=$(kubectl get ns "$ns" -o jsonpath='{.status.phase}')
              if [ "$phase" = "Terminating" ]; then
                echo "Force finalize $ns"
                kubectl get ns "$ns" -o json | jq 'del(.spec.finalizers)' \
                  | kubectl replace --raw "/api/v1/namespaces/$ns/finalize" -f - || true
              fi
            fi
          done

      - name: Deploy changed apps
        if: ${{ fromJSON(steps.matrix.outputs.matrix).include && fromJSON(steps.matrix.outputs.matrix).include[0] }}
        env:
          TARGET_CLUSTER: ${{ env.TARGET_CLUSTER }}
          # Rancher-specific
          RANCHER_HOSTNAME: ${{ vars.RANCHER_HOSTNAME }}
          LETSENCRYPT_EMAIL: ${{ vars.LETSENCRYPT_EMAIL }}
          RANCHER_BOOTSTRAP_PASSWORD: ${{ secrets.RANCHER_BOOTSTRAP_PASSWORD }}
          # Optional DB/object store secrets
          MARIADB_ROOT_PASSWORD: ${{ secrets.MARIADB_ROOT_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          MINIO_ROOT_USER: ${{ secrets.MINIO_ROOT_USER }}
          MINIO_ROOT_PASSWORD: ${{ secrets.MINIO_ROOT_PASSWORD }}
        run: |
          set -euo pipefail
          MATRIX_FILE=matrix.json
          ROOT="clusters/${TARGET_CLUSTER}"

          # helper ensure cert-manager once per run
          ensured_cm=0
          ensure_cert_manager () {
            if [ "$ensured_cm" -eq 0 ]; then
              echo ">> Installing/ensuring cert-manager"
              kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.15.3/cert-manager.yaml
              kubectl -n cert-manager rollout status deploy/cert-manager --timeout=180s || true
              kubectl -n cert-manager rollout status deploy/cert-manager-cainjector --timeout=180s || true
              kubectl -n cert-manager rollout status deploy/cert-manager-webhook --timeout=180s || true
              ensured_cm=1
            fi
          }

          for APP in $(jq -r '.include[]' "$MATRIX_FILE"); do
            echo -e "\n=== Deploy $APP ==="
            DIR="${ROOT}/${APP}"
            APP_CFG="${DIR}/app.yaml"
            VALS="${DIR}/values.yaml"

            if [ ! -f "$APP_CFG" ]; then
              echo "ERROR: $APP_CFG not found. Please add app.yaml for $APP"; exit 1
            fi
            [ -f "$VALS" ] || VALS=/dev/null

            NAME=$(yq -r '.name' "$APP_CFG")
            NAMESPACE=$(yq -r '.namespace' "$APP_CFG")
            CHART=$(yq -r '.chart' "$APP_CFG")
            REPO=$(yq -r '.repo // ""' "$APP_CFG")
            VERSION=$(yq -r '.version // ""' "$APP_CFG")
            NEED_CM=$(yq -r '.requires.certManager // false' "$APP_CFG")

            [ "$NAME" != "null" ] && [ "$NAMESPACE" != "null" ] && [ "$CHART" != "null" ]

            # Pre-req
            if [ "$NEED_CM" = "true" ]; then
              ensure_cert_manager
            fi

            # Namespace
            kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"

            # Chart reference
            if [ -n "$REPO" ] && echo "$REPO" | grep -q '^http'; then
              helm repo add "${NAME}-repo" "$REPO" || true
              helm repo update
              CHART_REF="${NAME}-repo/$(basename "$CHART")"
            else
              CHART_REF="$CHART"  # OCI or full name
            fi

            # Version flag
            VER_FLAG=""
            if [ -n "$VERSION" ]; then VER_FLAG="--version $VERSION"; fi

            # Extra sets (secrets/vars) per app
            EXTRA_SET=""
            if [ "$NAME" = "rancher" ]; then
              : "${RANCHER_HOSTNAME:?RANCHER_HOSTNAME variable required}"
              : "${LETSENCRYPT_EMAIL:?LETSENCRYPT_EMAIL variable required}"
              : "${RANCHER_BOOTSTRAP_PASSWORD:?RANCHER_BOOTSTRAP_PASSWORD secret required}"
              EXTRA_SET="$EXTRA_SET --set hostname=${RANCHER_HOSTNAME}"
              EXTRA_SET="$EXTRA_SET --set letsEncrypt.email=${LETSENCRYPT_EMAIL}"
              EXTRA_SET="$EXTRA_SET --set bootstrapPassword=${RANCHER_BOOTSTRAP_PASSWORD}"
            fi
            if [ "$NAME" = "mariadb-galera" ] && [ -n "${MARIADB_ROOT_PASSWORD:-}" ]; then
              EXTRA_SET="$EXTRA_SET --set auth.rootPassword=${MARIADB_ROOT_PASSWORD}"
            fi
            if [ "$NAME" = "redis" ] && [ -n "${REDIS_PASSWORD:-}" ]; then
              EXTRA_SET="$EXTRA_SET --set auth.password=${REDIS_PASSWORD}"
            fi
            if [ "$NAME" = "minio" ]; then
              [ -n "${MINIO_ROOT_USER:-}" ] && EXTRA_SET="$EXTRA_SET --set auth.rootUser=${MINIO_ROOT_USER}"
              [ -n "${MINIO_ROOT_PASSWORD:-}" ] && EXTRA_SET="$EXTRA_SET --set auth.rootPassword=${MINIO_ROOT_PASSWORD}"
            fi

            set -x
            helm upgrade --install "$NAME" "$CHART_REF" \
              --namespace "$NAMESPACE" \
              $VER_FLAG \
              -f "$VALS" \
              $EXTRA_SET
            set +x

            kubectl -n "$NAMESPACE" get pods,svc || true
          done

      - name: Summary
        run: |
          echo "Target cluster: $TARGET_CLUSTER"
          echo "Done processing changed apps."
